namespace UnitTests;

[Trait("Category", "Helpers")]
public sealed class EnumerableHelperTest
{
    private readonly string[] _names = new[] { "Nick", "Mike", "John", "Leyla", "David", "Damian" };

    [Fact]
    public void AddImmutedToKeyValuePairTest()
    {
        var dic = new List<int> { 0, 1, 2, 3, 4, };
        var dic1 = dic.AddImmuted(5);
        dic1 = dic1.AddImmuted(6);

        var expected_dic_count = 5;
        var expected_dic1_count = 7;

        Assert.Equal(expected_dic_count, dic.Count);
        Assert.Equal(expected_dic1_count, dic1.Count);
    }

    [Theory]
    [InlineData(null, null, new int[0])]
    [InlineData(new[] { 1, 2, 3 }, null, new[] { 1, 2, 3 })]
    [InlineData(null, new[] { 1, 2, 3 }, new[] { 1, 2, 3 })]
    [InlineData(new[] { 1, 2, 3 }, new[] { 4, 5, 6 }, new[] { 1, 2, 3, 4, 5, 6 })]
    public void AddRangeImmutedTest(IEnumerable<int> source, IEnumerable<int> items, IEnumerable<int> expected)
    {
        var actual = EnumerableHelper.AddRangeImmuted(source, items);
        Assert.Equal(expected, actual);
    }

    [Fact]
    public void AddToKeyValuePairTest()
    {
        var dic = new List<KeyValuePair<int, string>>
        {
            { 0, "Zero" },
            { 1, "One"},
            { 2, "Two"},
            { 3, "Three" },
            { 4, "Four" }
        };
        _ = dic.Add(5, "Fix");
        _ = dic.Add(6, "Six");
        var expected = 7;
        var actual = dic.Count;
        Assert.Equal(expected, actual);
    }

    [Fact]
    public void AggregateTest()
    {
        var first = new[] { 1, 2, 3 };
        var second = new[] { 4, 5, 6 };
        var merged = new[] { first, second };
        var actual = merged.SelectManyAndCompact();
        var expected = new[] { 1, 2, 3, 4, 5, 6 };
        Assert.True(expected.SequenceEqual(actual));
    }

    [Fact(Skip = "Not required in .Net ^6.0")]
    [Obsolete("Not required in .Net ^6.0")]
    public void ChunkByTest()
    {
        var chunks = this._names.ChunkBy(3);
        Assert.NotNull(chunks);
        Assert.Equal(2, chunks.Count());
        Assert.Equal(3, chunks.ElementAt(0).Count());
        Assert.Equal(3, chunks.ElementAt(1).Count());
        Assert.Equal("Leyla", chunks.ElementAt(1).ElementAt(0));
    }

    [Fact]
    public void CountNotEnumeratedTest()
        => Assert.Equal(6, this._names.CountNotEnumerated());

    [Theory]
    [InlineData(new[] { 1, 2, 3 }, new[] { 1, 2, 3 }, false, true)]
    [InlineData(new[] { 1, 2, 3 }, new[] { 1, 2, 3 }, true, true)]

    [InlineData(new[] { 1, 3, 2 }, new[] { 1, 2, 3 }, true, true)]
    [InlineData(new[] { 1, 3, 2 }, new[] { 1, 2, 3 }, false, false)]

    [InlineData(new[] { 1, 2, 3 }, new[] { 1, 2, 4 }, true, false)]
    [InlineData(new[] { 1, 2, 3 }, new[] { 1, 2, 4 }, false, false)]

    [InlineData(new[] { 1, 2 }, new[] { 1, 2, 3 }, true, false)]
    [InlineData(new[] { 1, 2 }, new[] { 1, 2, 3 }, false, false)]

    [InlineData(new[] { 1, 2, 3 }, new[] { 1, 2 }, true, false)]
    [InlineData(new[] { 1, 2, 3 }, new[] { 1, 2 }, false, false)]
    public void EqualTest(IEnumerable<int> ints1, IEnumerable<int> ints2, bool ignoreIndexes, bool expected)
    {
        var actual = EnumerableHelper.Equal(ints1, ints2, ignoreIndexes);
        Assert.Equal(expected, actual);
    }

    #region Generated by AI

    public static TheoryData<IEnumerable<object?>?, IEnumerable<object>> TestCompactData =>
        new()
        {
            { new string?[] { "a", "b", null, "c" }, new string[] { "a", "b", "c" } }, // Filter out a null value from a non-empty sequence
            { new string?[] { null, null, null }, Array.Empty<string>() }, // Filter out all null values from a non-empty sequence
            { Array.Empty<string?>(), Array.Empty<string>() }, // Filter out nothing from an empty sequence
            { null, Array.Empty<string>() } // Return an empty sequence for a null input
        };

    [Theory]
    [InlineData(new int[] { 1, 2, 3 }, 4, new int[] { 1, 2, 3, 4 })] // Add an item to a non-null array
    [InlineData(null, 5, new int[] { 5 })] // Add an item to a null array
    
    public void TestAddImmuted(int[]? input, int item, int[] expected) =>
        // Call the static method and assert the result
        Assert.Equal(expected, input.AddImmuted(item));

    [Theory]
    [InlineData(new int[] { 1, 2, 3 }, new int[] { 1, 2, 3 })] // Convert a non-empty list to a span
    [InlineData(new int[] { }, new int[] { })] // Convert an empty list to a span
    
    public void TestAsSpan(int[] input, int[] expected)
    {
        // Create a list from the input array
        var list = new List<int>(input);

        // Call the static method and assert the result
        Assert.Equal(expected, list.AsSpan().ToArray());
    }

    // Use Theory and MemberData attributes to test different cases
    [Theory]
    [MemberData(nameof(TestCompactData))]
    public void TestCompact(IEnumerable<object?>? input, IEnumerable<object> expected)
        // Call the static method and assert the result
        => Assert.Equal(expected, input.Compact());

    [Fact]
    public void Build_ReturnsReadOnlyList()
    {
        // Arrange
        var items = new List<int> { 1, 2, 3 };

        // Act
        var result = items.Build();

        // Assert
        Assert.Equal(items.Count, result.Count);
    }

    #endregion Generated by AI
}

#region Generated by AI
[Trait("Category", "Helpers")]
[Collection("FindDuplicatesTest")]
public sealed class FindDuplicatesTest
{
    [Fact]
    public void TestFindDuplicatesOnDistinctList()
    {
        // Arrange
        var list = new List<int> { 1, 2, 3, 4 };
        var expected = new List<int>();

        // Act
        var actual = list.FindDuplicates();

        // Assert
        Assert.Equal(expected, actual);
    }

    [Fact]
    public void TestFindDuplicatesOnNonDistinctList()
    {
        // Arrange
        var list = new List<int> { 1, 2, 3, 4, 2 };
        var expected = new List<int> { 2 };

        // Act
        var actual = list.FindDuplicates();

        // Assert
        Assert.Equal(expected, actual);
    }
}

[Trait("Category", "Helpers")]
[Collection("RemoveDefaultsTest")]
public sealed class RemoveDefaultsTest
{
    [Fact]
    public void TestRemoveDefaultsOnListWithDefault()
    {
        // Arrange
        var list = new List<int> { 1, 2, 0, 3 };
        var expected = new List<int> { 1, 2, 3 };

        // Act
        var actual = list.RemoveDefaults();

        // Assert
        Assert.Equal(expected, actual);
    }

    [Fact]
    public void TestRemoveDefaultsOnListWithNull()
    {
        // Arrange
        var list = new List<string?> { "a", "b", null, "c" };
        var expected = new List<string?> { "a", "b", "c" };

        // Act
        var actual = list.RemoveDefaults();

        // Assert
        Assert.Equal(expected, actual);
    }

    [Fact]
    public void TestRemoveDefaultsWithCustomValue()
    {
        // Arrange
        var list = new List<int> { 1, 2, -1, 3 };
        var expected = new List<int> { 1, 2, 3 };

        // Act
        var actual = list.RemoveDefaults(-1);

        // Assert
        Assert.Equal(expected, actual);
    }
}
#endregion